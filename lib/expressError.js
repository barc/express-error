// Generated by CoffeeScript 1.6.3
var CWD, FS, HOME, Path, Utils, alignLeft, betterStack, env, formatHtml, formatText, handleUncaughtExceptions, htmlEscape, http, injectSourceLines;

FS = require("fs");

Path = require("path");

Utils = require("./utils");

http = require("http");

env = process.env.NODE_ENV || "development";

HOME = process.env.HOME || process.env.USERPROFILE;

CWD = process.cwd();

alignLeft = function(lines) {
  var i, left, line, result, _i, _j, _k, _len, _len1, _ref, _results;
  result = [];
  left = Number.MAX_VALUE;
  for (_i = 0, _len = lines.length; _i < _len; _i++) {
    line = lines[_i];
    line.code = Utils.tabToSpaces(line.code);
    for (i = _j = 0, _ref = line.code.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
      if (line.code[i] !== " ") {
        left = Math.min(left, i);
      }
    }
  }
  _results = [];
  for (_k = 0, _len1 = lines.length; _k < _len1; _k++) {
    line = lines[_k];
    _results.push(line.code = line.code.slice(left));
  }
  return _results;
};

htmlEscape = function(s) {
  return String(s).replace(/&(?!\w+;)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
};

injectSourceLines = function(lines, contextLinesCount) {
  var cache, codeFile, coffee, col, collectSource, err, ext, i, lineObj, linenum, matches, newLines, pushLine, re, text;
  newLines = [];
  collectSource = true;
  cache = {};
  i = 1;
  while (i < lines.length) {
    lineObj = {
      frame: lines[i],
      code: []
    };
    newLines.push(lineObj);
    if (collectSource) {
      if (lines[i].indexOf('(') > 0) {
        re = /\((.*):(\d+):(\d+)\)/;
      } else {
        re = /at (.*):(\d+):(\d+)/;
      }
      matches = re.exec(lines[i]);
      if (matches) {
        console.log("MATCH>>", matches);
        codeFile = matches[1];
        if (codeFile.indexOf(HOME) === 0) {
          codeFile = codeFile.replace("~", HOME);
        }
        linenum = parseInt(matches[2]);
        col = matches[3];
        ext = Path.extname(codeFile);
        pushLine = function(text, suffix) {
          var j, textLines;
          suffix = suffix || "";
          textLines = text.split("\n");
          j = 0;
          while (j < textLines.length) {
            if (j >= (linenum - 1 - contextLinesCount) && (j < linenum - 1)) {
              lineObj.code.push({
                linenum: j + 1,
                code: textLines[j]
              });
            } else if (j === linenum - 1) {
              lineObj.code.push({
                linenum: j + 1,
                code: textLines[j],
                isErrorLine: true
              });
              if (!(contextLinesCount > 0)) {
                break;
              }
            } else if ((j > linenum - 1) && (j < linenum + contextLinesCount)) {
              lineObj.code.push({
                linenum: j + 1,
                code: textLines[j]
              });
              if (j === (linenum - 1 + contextLinesCount)) {
                break;
              }
            }
            j++;
          }
          return alignLeft(lineObj.code);
        };
        try {
          text = cache[codeFile];
          if (!text) {
            text = FS.readFileSync(codeFile, "utf8");
            if (ext === ".js") {
              cache[codeFile] = text;
            } else if (ext === ".coffee") {
              coffee = require("coffee-script");
              text = coffee.compile(text, {});
              cache[codeFile] = text;
            }
          }
          pushLine(text);
        } catch (_error) {
          err = _error;
          console.log(err.stack);
        }
      }
    }
    i++;
  }
  return newLines;
};

/*
Removes nodeunit specic line trace from stack and colors any
line from current test module.

@param {String} stack Error stack.
@param {Object} mod The test module.
@returns {String} Returns the modified stack trace.
*/


betterStack = function(stack, contextLinesCount) {
  var line, lines, result, _i, _len;
  if (!stack) {
    return "";
  }
  result = [];
  lines = stack.split("\n");
  for (_i = 0, _len = lines.length; _i < _len; _i++) {
    line = lines[_i];
    if (line.indexOf(CWD) > 0) {
      result.push(line.replace(CWD, "."));
    } else if (line.indexOf(HOME) > 0) {
      result.push(line.replace(HOME, "~"));
    } else {
      result.push(line);
    }
  }
  return injectSourceLines(result, contextLinesCount);
};

formatText = function(frames) {
  var frame, line, result, _i, _j, _len, _len1, _ref, _ref1;
  if (!(Array.isArray(frames) && frames.length > 0)) {
    return "";
  }
  result = "";
  for (_i = 0, _len = frames.length; _i < _len; _i++) {
    frame = frames[_i];
    result += frame.frame + "\n";
    if (((_ref = frame.code) != null ? _ref.length : void 0) > 0) {
      _ref1 = frame.code;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        line = _ref1[_j];
        result += "        " + (Utils.padLeft(line.linenum.toString(), 4)) + ": " + line.code + "\n";
      }
    }
  }
  return result;
};

formatHtml = function(frames) {
  var attr, frame, line, result, _i, _j, _len, _len1, _ref, _ref1;
  if (!(Array.isArray(frames) && frames.length > 0)) {
    return "";
  }
  result = "<ul>";
  for (_i = 0, _len = frames.length; _i < _len; _i++) {
    frame = frames[_i];
    result += "<li>";
    result += "  <div class='frame'>" + htmlEscape(frame.frame) + "</div>";
    if (((_ref = frame.code) != null ? _ref.length : void 0) > 0) {
      result += "  <ul class='source'>";
      _ref1 = frame.code;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        line = _ref1[_j];
        attr = line.isErrorLine ? "class='error-line'" : "";
        result += "  <li " + attr + ">";
        result += "<pre>" + Utils.padLeft(line.linenum.toString(), 4) + ": " + htmlEscape(line.code) + "</pre>";
        result += "  </li>";
      }
      result += "  </ul>";
    }
    result += "</li>";
  }
  return result += "</ul>";
};

handleUncaughtExceptions = function(contextLinesCount) {
  return process.on("uncaughtException", function(err) {
    var stack;
    stack = err.stack ? formatText(betterStack(err.stack, contextLinesCount)) : "";
    return console.error("Uncaught exception", "" + err.message + "\n" + stack);
  });
};

exports.express3 = function(options) {
  var contextLinesCount, dumpExceptions, handleUncaughtException, showStack, title;
  if (options == null) {
    options = {};
  }
  showStack = options.showStack || false;
  dumpExceptions = options.dumpExceptions || false;
  handleUncaughtException = options.handleUncaughtException || false;
  contextLinesCount = options.contextLinesCount || 0;
  title = options.title || "express-error";
  if (handleUncaughtException) {
    handleUncaughtExceptions(contextLinesCount);
  }
  return function(err, req, res, next) {
    var accept, message, name, newerr, status;
    if (typeof err === "number") {
      status = err;
      name = http.STATUS_CODES[status];
      err = new Error(name);
      err.name = name;
      err.status = status;
    } else if (typeof err === "string") {
      name = err;
      err = new Error(name);
      err.name = name;
      err.status = 500;
    }
    if (err.status) {
      res.statusCode = err.status;
    }
    if (res.statusCode < 400) {
      res.statusCode = 500;
    }
    accept = req.headers.accept || "";
    if (err instanceof Error) {
      newerr = {
        message: err.message,
        stack: betterStack(err.stack, contextLinesCount)
      };
    } else if (err) {
      if (typeof err === 'string') {
        newerr = {
          message: err,
          stack: null
        };
      } else {
        message = JSON.stringify(err);
        newerr = {
          message: message,
          stack: null
        };
      }
    } else {
      message = "(empty error)";
      newerr = {
        message: message,
        stack: null
      };
    }
    if (env === "development") {
      console.error(formatText(newerr.stack));
    }
    if (~accept.indexOf("html")) {
      return FS.readFile(__dirname + "/../public/style.css", "utf8", function(e, style) {
        return FS.readFile(__dirname + "/../public/error.html", "utf8", function(e, html) {
          var stack;
          stack = formatHtml(newerr.stack);
          html = html.replace("{style}", style).replace("{stack}", stack).replace("{title}", title).replace("{statusCode}", res.statusCode).replace(/\{error\}/g, htmlEscape(newerr.message));
          res.setHeader("Content-Type", "text/html; charset=utf-8");
          return res.end(html);
        });
      });
    } else if (~accept.indexOf("json")) {
      return res.json(newerr);
    } else {
      res.setHeader("Content-Type", "text/plain");
      return res.end(JSON.stringify(newerr));
    }
  };
};

exports.express2 = exports.express3;
